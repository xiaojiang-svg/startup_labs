**这个md主要是为了搞清楚boot是什么、loader是什么以及bootloader如何运行**

# Boot
问gpt都给问烦了，所以结合大量的拷问，我对BOOT是什么东西做一个小的概括说明

Boot叫做**引导**，指的是系统上电后执行的启动流程，这个启动流程呢，大家对这个概念都很模糊啊，所以可以转至我的另一文档StartupWithoutMMU.md。这个Boot引导过程是一种抽象的概念，不是具体的代码，它指的是由硬件和软件共同完成的可以让程序运行的环境初始化过程，不仅包括了硬件的复位、初始化，也包括了C/C++运行时环境初始化。

# Loader
Loader叫做**加载器**，从字面意思上可以知道它肯定是一段代码，要从非易失性的存储器中加载点什么东西到其他地方，所以它的任务一般都是将程序从Flash或者ROM中加载到RAM以提高执行速度。
这个程序呢，指的是OS或者应用程序，我会详细地讲述有OS的启动流程和没有OS的启动流程以及两种不同情况的代码运行环境和中断处理流程。
**_我应该还会和一个朋友补充一个关于自定义Bootloader的实验，后续也会上传至该工程。_**

# BootLoader
具体一点可以这样子说，可以看到我们本工程的startup_stm32h743xx.S，里面有一段是关于DataCopy的，这其实算是一个极简版的loader，只是加载了一点数据进去，但其实加载程序也是这样的方式。
再退一步说，进入main之前，我都可以认为是在Boot阶段，startup.s就是一个Bootloader，它既负责了硬件的初始化--包括FPU的启用、系统时钟的配置、Debug调试信息的确认，又负责了程序的运行初始化--DataCopy至SRAM、引导进入main函数（由于我没有用到C++，所以关于C++的构造和析构相关的程序最后链接器似乎帮我进行了优化--这个我有待查证），所以你完全可以把startup_stm32h743xx.S当作一个简易版的bootloader。

当然我们经常在说Bootloader要负责检测固件升级，第一要明白什么是固件。固件不是硬件，不是固体，它是存储在RAM、FLASH或者EEPROM中的一种低级软件，用于控制硬件设备的基本操作。所以你可以将它当作硬件系统的一部分，因为它就是面向特定硬件进行设计的，一般包括MCU的Bootloader、计算机主板的BIOS/UEFI、硬盘、打印机、鼠标、键盘的内部控制程序等等，既然本质上还是软件，那么就可以实现更新--一般通过在线升级（OTA）、USB、串口等方式进行。

然后我想说一下Bootloader是如何检测固件升级的。
1. 外部触发检测--手动升级。我们有些时候使用的按住BOOT上电、或者是监听UART等待指令、或者是PC段工具通过USB触发升级

2. 通过FLASH标志位检测--软件触发。bootloader会在启动时检查Flash的某个特定区域的标志位--Magic Number。是用于在线升级，即MCU在运行是决定是否升级
流程为：应用程序检测到新固件 → 写入升级标志位 → 复位 MCU → Bootloader 启动 → 读取 Flash 标志位 → 进入升级模式 → 升级完成 → 清除标志位 → 重新启动

3. 外部存储检测。Bootloader通过检测SD卡或者EEPROM是否有新的固件文件.bin来读取并更新

4. 通过网络检测--OTA升级。这个通过网络连接到服务器，检查是否有新固件，我在想这个是不是手机系统升级的方式呢？--有待考究

所以咋说呢？显而易见这个东西在startup_stm32h743xx.S这一类启动文件中同样可以做到。诸如这一类工作都可以通过统一映射的地址来对相应的GPIO口、外部存储、FLASH、网络设备进行检测，也就是通过汇编代码直接在硬件层面去看他们的状态，所以BootLoader也就是这么个东西，实现的功能也就是那么个功能。

嗷，对了，还有一点提醒，为什么这个需要将代码拷贝呢，可以移步**loadDomain_and_exeDomain.md**

